1. Walk us through your development process as you worked on this project. How did you plan out the structure and design of it? How did decide on the tools you've used? Did you encounter any problems? And if so, how did you solve them? Are there any areas of your code that you're particularly proud of or want to point out?

The first step in my development project was to determine what libraries and tools to use. I quickly chose to use React since it is the library I'm most proficient at. I also opted to use TypeScript instead of JavaScript since I feel that integrated type-checking in my code minimizes the number of bugs in my code and helps me notice issues earlier on. I, of course, used ESLint and Prettier, because clean and consistent code is better. I wanted to use some pre-styled component library to help speed up the development process. I was debating between Material UI and React Bootstrap. After previously working with both, I found that React Bootstrap speeds the development time more but Material UI yields a better result in the end. Due to the time constraint, I ended up opting for React Bootstrap. However, I still used Styled Components, as it would allow me to easily tweak the styling to my liking. I used Luxon to help manage the dates better and used Axios for my API calls. Granted, with only one API call and very few dates, I could have not used them. However, if this project was to be extended and scaled up, their value would become much more apparent. Finally, I used Storybook, simply to improve my development speed by allowing me to work on components in isolation.

After installing all my packages, the next step was to start developing. I personally do not like working on the front-end side without a strong foundation (unless it's a personal project and I just want to play around). Additionally, I do not have any control over the back-end, so my front-end code must be structured around how the back-end is structured. To create this structure, I first created an `Event` model. This is simply a Typescript class that represents the events return from the API call. Defining it as a concrete class forces my front-end code to be structured in the same way as the back-end and prevents me from handling the data incorrectly. Along with the `Event` model (which also contains `EventType` and `Permission`), I also have an `Api` model that wraps a lot of the API logic. Then for my different models, I'm able to write an `EventApi` class that handles the API call for the events. This prevents duplicated code, as in the case that more models were created (e.g. Users, Judges, etc.), I would just create a corresponding API class for the model and use the `Api` model. Additionally, it separates the models into different directories, making it easier for other developers to understand and see the relevant code.

Additionally, I divided the project into three main directories: components, library, and models. Components stores code relevant to the front-end, models stores the class definitions more my different models, and library stores supporting files, such as a `config.json` (which stores configuration values) and `data.ts` (which stores the data statically, which can be used for tests and Storybook). Dividing my code in such a way makes it a lot more navigable, as it separates distinct pieces of logic into distinct directories. Granted, if this project were to be extended, more directories would need to be made, such as a hooks directory and a sections directory to store different sections of the site. However, since the application is currently quite small, this file structure sufficed.

Now with my strong foundation, I began developing the front-end. I typically go with the "develop small components and work your way up" philosophy. I find that it is more efficient, allows me to reuse code, and the logic in individual components is shorter and simpler. When it comes to the bigger picture stuff, I tend to start with the most crucial pieces first. In my opinion, the most important aspect of this challenge was the component that displays an event's information. I wasn't exactly sure how I wanted it to look, so I went through the fields of an event and filtered out the ones that I don't need to display (e.g. `id`, `permission`, etc.). With the remaining fields, I laid out the ones that always display (e.g. `name`, `event_type`, `start_time`, etc.). I then integrated the fields that display conditionally (e.g. `private_url`, `public_url`, `speakers`, etc.). I sort of went with what I thought made sense and looked well (e.g. `name` should be the first thing since it's the most important, followed by the time and date) and ended coming up with a design that I liked (I also had to consider how it would look on mobile). Now to implement, I separate my design into separate components, implemented them each, and pieced together my event card.

Now having a card to represent a single event, I debated back and forth between how I wanted to list all the events. My two main ideas were to either simply list them or display them in a sort-of schedule based on the time and date of the event. Since just displaying them in a list takes less than 5 minutes to do, I did this for the time being and prioritized the log-in functionality first.

Log-in functionality was simple since it was hard-coded. I wanted to implement real authentication, but due to the time constraint, I decided not to, since I didn't think it added as much value as other features I could implement instead would.

Finally coming back to whether or not I would display the events in a schedule, I still wasn't sure if it was worth it. Yes, it improves the design significantly. However, when it comes to web development, I need to consider both design and functionality. At this point, the application had very little functionality (despite logging in to display private events and URLs). Due to this, I thought adding even a bit of functionality would provide more value than displaying the events in a schedule. I also re-read the challenge instructions and I realized I forgot to implement *Provide a way to link to and view each related event*. There were a few ways I could go about implementing this. However, I did want to at least start some sort of filtering functionality, so to keep the application consistent, I figured it would make sense to make viewing related events a filtering mechanism. Thus, I implemented a filtering mechanism that allows you to filter by related events of a specific event and the three different event types. I also designed my filtering component by making the logic more general to allow for future filters to be easily implemented (such as filtering by date range).

There are two things that I'm somewhat proud of in my code. They may sound dumb, but I think they're quite important. The first thing I'm proud of is how I handled component state logic. I kept everything clean and consistent, used modern React hooks, and made sure to not allow components to directly alter another component's state logic (I made wrapper methods instead). I find it neat and easier to understand when the state logic is simple and clear, which is why I take extra care in my code and am a bit proud. I also am proud of how I made the code general enough that it could be extended. For example, I defined the different event types in the `Event` model and use that throughout my code. Thus, if I wanted to add more event types, I only really need to change it in one place. Granted, there is some tweaking I would probably still have to do throughout the code, but it is still decently general, which I'm proud of.

2. Given additional time, how would you extend your application to become a fully functional product that thousands of hackers and the general public would use at Hackathon Global Inc.â„¢'s next event?

As much as I'm proud of what I implemented over one weekend, I do have to admit that there are a decent number of things that I could add to my application to make it a fully functional product. Firstly, a real authentication system. My hard-coded values clearly wouldn't work for thousands of hackers. Another thing would be to have things persist through refreshes. For example, keeping users logged in through a refresh is pretty crucial. Also perhaps representing the filters in a query string so that the filters would stay if the site was refreshed and users could bookmark specific filters. Another thing of course would be to add analytic tracking. This would allow me to see what features the users are using and what are not.

Beyond functionality, that are design and code logic extensions I would also make. I would want to handle the icon for sponsors better. Currently, I just display a default icon for the sponsors that are companies rather than people. It would look a lot better if I got all the sponsors' company logos and displayed them instead. Additionally, the buttons for the URLs only support Hopin and YoTube. It would be better to make them more general in the case that the URL is another site, such as Twitch. Finally, creating a more designed theme and adding packages to improve code logic (such as lodash) would help solidify my application as a fully functional product.